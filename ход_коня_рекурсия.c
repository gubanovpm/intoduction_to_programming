#include <stdio.h>
#include <stdlib.h>

// перебор с возвратом без правила Варнсдорфа
// идем рекурсивно в глубину функции, где глубина - номер хода
// если попадаем в ситуацию, где невозможен никакой ход, а 
// глубина(т е номер хода не равен последнему возможному(т е N * N), 
// то возвращаемся на уровень, где флаг еще был равен 1 и рассматриваем оставшиеся варианты

void knight_turn(int **board, int N, int M, int i, int j, int d);
void print_board(int **board, int N, int M);
int isMovePossible(int x, int y, int N, int M);

unsigned long long main() {

	printf("Enter the board size:\n");			// ввод размеров доски
	int N = 0, M = 0;
	scanf("%d%d", &N, &M);

	int **board = (int **)malloc(N * sizeof(int *));	// выделение памяти на доску как на указатель на указатели
	for (int i = 0; i < N; i++)								// двумерный массив, в котором int ** указатель на указетли начал массивов(массивы массивов)
		board[i] = (int *)calloc(M, sizeof(int));		// зануление всех элементов на которые выделяется память

	printf("Knight's position on %dx%d board?\n", N, M); // пользовательский ввод начальной позиции коня
	int i = 0, j = 0;
	scanf("%d%d", &i, &j);
	i--;												// так как внутри программы строки начинаются с 0, а реальные начинаются с 1
	j--;
	board[i][j] = 1;									// стартуем с начальной позиции, т е в считанной позиции мы находимся на момент 1 хода
	
	knight_turn(board, N, M, i, j, 2);					// вызов рекрсивной функции перебора ответа до правильного(описание параметров смотри в описании функции ниже)
	return 0;

}

// основная рекурсивная функция
void knight_turn(int **board, int N, int M, int i, int j, int d) { // передаваемые параметры - указатель на доску с её текущим состоянием, размеры доски текущие координаты коня и номер хода, который мы производим
//	print_board(board, N, M);                        // чтобы посмотреть все вспомогательные матрицы расскомментируй
	int turn_x[8] = { 1,  2,  1,  2, -1, -2, -1, -2};			// массивы изменения координат, каждому i-ому смещению по оси x
	int turn_y[8] = { 2,  1, -2, -1,  2,  1, -2, -1};			// соответствует i-ое смещение по оси y
	int x = 0, y = 0;											// вспомогательные переменные, отвещающие куда мы попадем ходом коня
	for (int k = 0; k < 8; k++) {								// перебор по всем возможным ходам с точки с координатами i j
		x = j + turn_x[k];										// вычесление координат для каждого k-ого хода
		y = i + turn_y[k];
		if (isMovePossible(x, y, N, M) && board[y][x] == 0) {	// проверим возможен ли ход - т е не происходит ли обращеие к ячейкам вне текущей матрицы и не занята ли клетка в которую мы идём
			board[y][x] = d;									// если ход возможен будем рассматривать это как новую ветку текущего дерева состояния, поместив в эту клетку значение номера текущего хода
			if (d == N * M) {									// если текущий ход - последний, то выведем на экран и прекатим выполнение программы
				print_board(board, N, M);
				for (int i = 0; i < N; i++)							// очищение выдеделенной памяти для хранения доски с обходом
					free(board[i]);
				free(board);
				exit(0);
			}
			knight_turn(board, N, M, y, x, d + 1);				// если обход не окончен, то рекурсивно опустимся вниз, считая новые координаты за текущие, и изменив наодин номер текущего шага
			board[y][x] = 0;									// чтобы рассматривать все возможные варианты, будем занулять по выходу из конечного рекуривного дерева(т е когда мы рассмторели все возможные последующие ходы из текущей клетки по доске на момент вхождения)
		}
	}
}

// вспомогательная функция вывода матриц на экран
void print_board(int **board, int N, int M) {
	for (int i = 0; i < N; i++) {					// если мы смогли обойти выводим номер хода которым мы туда попали
		for (int j = 0; j < M; j++)					// иначе выводи ###(три так как чиселки выврдятся в подобном формате чтобы было достаточно красиво)
			if (board[i][j] != 0)
				printf("%3d", board[i][j]);
			else
				printf("###");
		printf("\n");
	}
	printf("\n");
}


// вспомогательная функция для проверки: не выходим ли мы за границы 
int isMovePossible(int x, int y, int N, int M) {
	return ((-1 < x) && (x < M) && (-1 < y) && (y < N)); // случаи выхождения за границы - обращение к координате меньшей нуля или большего максимаьного граничного значения
}
